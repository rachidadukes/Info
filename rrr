

using Spectre.Console;
using System.Xml;
using System.Text;

public static class ConsoleDisplayHelper
{
    private static readonly List<(DateTime When, UserInputModel Input, string WhichService)> _history = new();

    public static void PrintStickySummary(UserInputModel u)
    {
        if (u == null) return;

        AnsiConsole.Write(new Rule("[green]Selections[/]").RuleStyle("grey"));
        AnsiConsole.MarkupLine($"[yellow]Environment:[/] {u.Environment}");
        AnsiConsole.MarkupLine($"[yellow]Account Type:[/] {u.AccountType}");
        AnsiConsole.MarkupLine($"[yellow]Account Number:[/] {u.AccountNumber}");
        AnsiConsole.MarkupLine($"[yellow]Transaction:[/] {u.TranName} (Code: {u.TranCode})");
        AnsiConsole.MarkupLine($"[yellow]Amount:[/] {u.TransAmt}");
        AnsiConsole.Write(new Rule().RuleStyle("grey"));
    }

    public static void AddToHistory(UserInputModel u, string whichService)
    {
        if (u == null) return;
        _history.Add((DateTime.Now, u, whichService));
    }

    public static void RenderHistory()
    {
        if (_history.Count == 0) return;

        var table = new Table().Border(TableBorder.Rounded);
        table.AddColumn("When");
        table.AddColumn("Service");
        table.AddColumn("Env");
        table.AddColumn("Tran");
        table.AddColumn("Acct#");
        table.AddColumn("Amt");

        foreach (var h in _history)
        {
            table.AddRow(
                h.When.ToString("yyyy-MM-dd HH:mm:ss"),
                h.WhichService,
                h.Input.Environment,
                $"{h.Input.TranName} ({h.Input.TranCode})",
                h.Input.AccountNumber,
                h.Input.TransAmt
            );
        }

        AnsiConsole.Write(new Rule("[grey]Run History[/]").RuleStyle("grey"));
        AnsiConsole.Write(table);
    }

    // ---------- NEW: XML SUMMARY & UTILITIES ----------

    /// <summary>
    /// Render compact previews of XML request and response.
    /// </summary>
    /// <param name="xmlRequest">Raw XML string for the request.</param>
    /// <param name="xmlResponse">Raw XML string for the response.</param>
    /// <param name="previewLines">Max number of lines to show in preview (each).</param>
    /// <param name="offerExpand">If true, prompt user to show full XML inline.</param>
    public static void RenderXmlSummary(string xmlRequest, string xmlResponse, int previewLines = 24, bool offerExpand = true)
    {
        // REQUEST
        RenderOneXmlBlock("XML Request", xmlRequest, previewLines, offerExpand);

        // RESPONSE
        RenderOneXmlBlock("XML Response", xmlResponse, previewLines, offerExpand);
    }

    private static void RenderOneXmlBlock(string title, string xml, int previewLines, bool offerExpand)
    {
        AnsiConsole.Write(new Rule($"[blue]{title}[/]").RuleStyle("grey"));

        if (string.IsNullOrWhiteSpace(xml))
        {
            AnsiConsole.MarkupLine("[red]No XML available.[/]");
            return;
        }

        // Pretty-print but be resilient if XML is malformed
        string pretty = TryPrettyXml(xml, indent: 2, out bool wellFormed);

        // Show preview first
        var (preview, truncated) = TakeFirstLines(pretty, previewLines);

        var panel = new Panel(EscapeMarkup(preview))
            .Header($"{title} Preview{(truncated ? $" (first {previewLines} lines)" : "")}")
            .Border(BoxBorder.Rounded);

        // If malformed, annotate header
        if (!wellFormed)
            panel = panel.Header($"{title} Preview (not well-formed; raw shown)");

        AnsiConsole.Write(panel);

        if (offerExpand && truncated)
        {
            if (AnsiConsole.Confirm($"Show full {title.ToLower()}?"))
            {
                var fullPanel = new Panel(EscapeMarkup(pretty))
                    .Header($"{title} (Full)")
                    .Border(BoxBorder.Rounded);
                AnsiConsole.Write(fullPanel);
            }
        }
    }

    /// <summary>
    /// Try to pretty-print XML. Falls back to raw if not well-formed.
    /// </summary>
    private static string TryPrettyXml(string xml, int indent, out bool wellFormed)
    {
        wellFormed = true;
        try
        {
            var doc = new XmlDocument();
            doc.PreserveWhitespace = false;
            doc.LoadXml(xml);

            var sb = new StringBuilder();
            var settings = new XmlWriterSettings
            {
                OmitXmlDeclaration = false,
                Indent = true,
                IndentChars = new string(' ', indent),
                NewLineHandling = NewLineHandling.Entitize
            };
            using var writer = XmlWriter.Create(sb, settings);
            doc.Save(writer);
            return sb.ToString();
        }
        catch
        {
            wellFormed = false;
            // fallback: return raw trimmed text
            return xml?.Trim() ?? string.Empty;
        }
    }

    /// <summary>
    /// Returns first N lines with a flag indicating if truncation occurred.
    /// </summary>
    private static (string text, bool truncated) TakeFirstLines(string input, int maxLines)
    {
        if (maxLines <= 0 || string.IsNullOrEmpty(input))
            return (input ?? string.Empty, false);

        var lines = input.Replace("\r\n", "\n").Split('\n');
        if (lines.Length <= maxLines)
            return (string.Join('\n', lines), false);

        var head = string.Join('\n', lines[..maxLines]);
        return ($"{head}\n... (truncated; {lines.Length - maxLines} more lines)", true);
    }

    /// <summary>
    /// Escapes Spectre markup so XML renders verbatim inside Panel.
    /// </summary>
    private static string EscapeMarkup(string s) => Markup.Escape(s ?? string.Empty);
}
