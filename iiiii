using System;
using System.Configuration;
using System.Diagnostics;
using System.Linq;
using System.Net;
using System.Net.Http;
using System.Net.Security;
using System.Net.Sockets;
using System.Security.Authentication;
using System.Security.Cryptography.X509Certificates;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

namespace RestServiceApp
{
    public static class HealthProbe
    {
        private const int TcpConnectSeconds = 3;
        private const int HttpTimeoutSeconds = 5;

        // optional appSetting: <add key="IgnoreServerCertificateErrors" value="false" />
        private static readonly bool IgnoreCertValidation =
            bool.TryParse(ConfigurationManager.AppSettings["IgnoreServerCertificateErrors"], out var b) && b;

        /// <summary>
        /// Performs DNS → TCP → TLS → HTTP health diagnostics for the given base URL and optional health path.
        /// Never throws; fills <paramref name="ApiHealthDiag"/> with the root cause on failure.
        /// </summary>
        public static async Task<ApiHealthDiag> DiagnoseAsync(
            string url,
            string healthPath = null,
            CancellationToken ct = default)
        {
            var diag = new ApiHealthDiag();
            var sw = Stopwatch.StartNew();

            try
            {
                // Prefer modern protocols for legacy ServicePoint-based stacks
#pragma warning disable SYSLIB0039
                ServicePointManager.SecurityProtocol = SecurityProtocolType.Tls12 | (SecurityProtocolType)12288; // 12288 ~ TLS1.3 if available on platform
#pragma warning restore SYSLIB0039

                var uri = new Uri(url);
                var healthUri = new Uri(uri, healthPath ?? "/health");

                // 1) DNS
                if (!TryDnsResolve(uri, diag))
                    return Finalize(sw, diag);

                // 2) TCP
                if (!await TryTcpConnectAsync(uri, diag, ct).ConfigureAwait(false))
                    return Finalize(sw, diag);

                // 3) TLS + 4) HTTP
                var ok = await DiagnoseTlsAndHttpAsync(healthUri, diag, ct).ConfigureAwait(false);
                if (!ok)
                    return Finalize(sw, diag);

                // Success
                diag.PhaseFailed = string.Empty;
                diag.Reason = string.Empty;
                return Finalize(sw, diag);
            }
            catch (OperationCanceledException) when (ct.IsCancellationRequested)
            {
                diag.PhaseFailed = "Canceled";
                diag.Reason = "Probe canceled by caller.";
                return Finalize(sw, diag);
            }
            catch (Exception ex)
            {
                // last-ditch guard: never let exceptions escape
                diag.PhaseFailed = "Unexpected";
                diag.Reason = ex.Message;
                return Finalize(sw, diag);
            }
        }

        // -------------------- DNS --------------------

        private static bool TryDnsResolve(Uri uri, ApiHealthDiag diag)
        {
            try
            {
                var host = uri.Host;
                var entries = Dns.GetHostAddresses(host);
                if (entries is { Length: > 0 })
                    return true;

                diag.PhaseFailed = "DNS";
                diag.Reason = $"No A/AAAA records for {host}.";
                return false;
            }
            catch (SocketException se)
            {
                diag.PhaseFailed = "DNS";
                diag.Reason = $"DNS error: {se.Message}";
                return false;
            }
            catch (Exception ex)
            {
                diag.PhaseFailed = "DNS";
                diag.Reason = ex.Message;
                return false;
            }
        }

        // -------------------- TCP --------------------

        private static async Task<bool> TryTcpConnectAsync(Uri uri, ApiHealthDiag diag, CancellationToken ct)
        {
            using var tcp = new TcpClient();
            var host = uri.Host;
            var port = uri.Port == -1 ? (uri.Scheme == Uri.UriSchemeHttps ? 443 : 80) : uri.Port;

            try
            {
                var ok = await ConnectWithTimeoutAsync(tcp, host, port, TimeSpan.FromSeconds(TcpConnectSeconds), ct)
                    .ConfigureAwait(false);
                if (ok) return true;

                diag.PhaseFailed = "TCP";
                diag.Reason = $"Could not connect to {host}:{port} within {TcpConnectSeconds}s.";
                return false;
            }
            catch (Exception ex)
            {
                diag.PhaseFailed = "TCP";
                diag.Reason = $"TCP error: {ex.Message}";
                return false;
            }
        }

        private static async Task<bool> ConnectWithTimeoutAsync(
            TcpClient tcp, string host, int port, TimeSpan timeout, CancellationToken ct)
        {
            using var cts = CancellationTokenSource.CreateLinkedTokenSource(ct);
            cts.CancelAfter(timeout);

            try
            {
#if NET6_0_OR_GREATER
                await tcp.ConnectAsync(host, port, cts.Token).ConfigureAwait(false);
#else
                var t = tcp.ConnectAsync(host, port);
                using (cts.Token.Register(() => { try { tcp.Close(); } catch { } }))
                    await t.ConfigureAwait(false);
#endif
                return tcp.Connected;
            }
            catch
            {
                return false;
            }
        }

        // -------------------- TLS + HTTP --------------------

        private static async Task<bool> DiagnoseTlsAndHttpAsync(
            Uri healthUri,
            ApiHealthDiag diag,
            CancellationToken ct)
        {
            SslPolicyErrors lastTlsErrors = SslPolicyErrors.None;
            X509Certificate2 serverCert = null;
            X509ChainStatus[] chainIssues = Array.Empty<X509ChainStatus>();

            using var handler = CreateHandler(out lastTlsErrors, out serverCert, out chainIssues);
            using var client = new HttpClient(handler)
            {
                Timeout = TimeSpan.FromSeconds(HttpTimeoutSeconds)
            };

            try
            {
                using var resp = await TryHeadOrGetAsync(client, healthUri, ct).ConfigureAwait(false);

                // -- capture TLS results regardless of HTTP result
                diag.TLSok = lastTlsErrors == SslPolicyErrors.None || IgnoreCertValidation;
                diag.TLSErrors = lastTlsErrors.ToString();
                diag.CertSummary = SummarizeCert(serverCert, chainIssues);

                if (!diag.TLSok && !IgnoreCertValidation)
                {
                    MarkTlsFailure(diag, lastTlsErrors, serverCert,
                        "TLS handshake had policy errors. See TLSErrors/CertSummary.");
                    return false;
                }

                if (resp == null)
                {
                    diag.PhaseFailed = "HTTP";
                    diag.HttpOk = false;
                    diag.Reason = "No response received (HEAD and GET both failed).";
                    return false;
                }

                // HTTP layer outcome
                diag.HttpOk = resp.IsSuccessStatusCode;
                diag.HttpStatusCode = (int)resp.StatusCode;
                diag.HttpReasonPhrase = resp.ReasonPhrase ?? string.Empty;

                if (!diag.HttpOk)
                {
                    diag.PhaseFailed = "HTTP";
                    diag.Reason = $"HTTP {(int)resp.StatusCode} {resp.ReasonPhrase}";
                    return false;
                }

                // Optionally capture small response body sample
                // var body = await resp.Content.ReadAsStringAsync(ct).ConfigureAwait(false);
                // diag.ResponseSample = body.Length <= 512 ? body : body.Substring(0, 512);

                return true;
            }
            catch (TaskCanceledException)
            {
                diag.TLSok = false;
                diag.PhaseFailed = "Timeout";
                diag.Reason = $"Timed out after {HttpTimeoutSeconds}s.";
                diag.CertSummary = SummarizeCert(serverCert, chainIssues);
                return false;
            }
            catch (HttpRequestException hre)
            {
                diag.TLSok = false; // transport/TLS likely failed before HTTP
                diag.PhaseFailed = "TLS/Transport";
                var tlsHint = ExplainTlsErrors(lastTlsErrors);
                diag.Reason = $"{hre.Message}{(string.IsNullOrEmpty(tlsHint) ? "" : " | " + tlsHint)}";
                diag.CertSummary = SummarizeCert(serverCert, chainIssues);
                return false;
            }
            catch (Exception ex)
            {
                diag.TLSok = false;
                diag.PhaseFailed = "Unexpected";
                diag.Reason = ex.Message;
                diag.CertSummary = SummarizeCert(serverCert, chainIssues);
                return false;
            }
        }

        private static HttpClientHandler CreateHandler(
            out SslPolicyErrors lastTlsErrors,
            out X509Certificate2 serverCert,
            out X509ChainStatus[] chainIssues)
        {
            lastTlsErrors = SslPolicyErrors.None;
            serverCert = null;
            chainIssues = Array.Empty<X509ChainStatus>();

            var handler = new HttpClientHandler
            {
#if NET6_0_OR_GREATER
                SslProtocols = SslProtocols.Tls12 | SslProtocols.Tls13,
#else
                SslProtocols = SslProtocols.Tls12,
#endif
                CheckCertificateRevocationList = true
            };

            handler.ServerCertificateCustomValidationCallback = (request, cert, chain, errors) =>
            {
                // capture
                lastTlsErrors = errors;
                if (cert is X509Certificate2 c2) serverCert = c2;
                if (chain is not null && chain.ChainStatus is { Length: > 0 })
                    chainIssues = chain.ChainStatus;

                // DO NOT bypass in production unless explicitly configured
                if (IgnoreCertValidation) return true;

                // Let .NET enforce normal validation; we just captured details
                return errors == SslPolicyErrors.None;
            };

            return handler;
        }

        private static async Task<HttpResponseMessage> TryHeadOrGetAsync(
            HttpClient client,
            Uri healthUri,
            CancellationToken ct)
        {
            // Some servers reject HEAD; try HEAD then fall back to GET
            try
            {
                using var head = new HttpRequestMessage(HttpMethod.Head, healthUri);
                var headResp = await client.SendAsync(head, HttpCompletionOption.ResponseHeadersRead, ct)
                                           .ConfigureAwait(false);
                return headResp;
            }
            catch
            {
                // swallow and try GET
            }

            try
            {
                using var get = new HttpRequestMessage(HttpMethod.Get, healthUri);
                var getResp = await client.SendAsync(get, HttpCompletionOption.ResponseHeadersRead, ct)
                                          .ConfigureAwait(false);
                return getResp;
            }
            catch
            {
                return null;
            }
        }

        private static void MarkTlsFailure(
            ApiHealthDiag diag,
            SslPolicyErrors lastTlsErrors,
            X509Certificate2 serverCert,
            string message)
        {
            diag.TLSok = false;
            diag.TLSErrors = lastTlsErrors.ToString();
            diag.CertSummary = SummarizeCert(serverCert, null);
            diag.PhaseFailed = "TLS";
            diag.Reason = message;
        }

        private static ApiHealthDiag Finalize(Stopwatch sw, ApiHealthDiag diag)
        {
            sw.Stop();
            // If you track duration, set it here, e.g. diag.DurationMs = sw.ElapsedMilliseconds;
            return diag;
        }

        // -------------------- Utility --------------------

        private static string SummarizeCert(X509Certificate2 cert, X509ChainStatus[] chainIssues)
        {
            if (cert == null) return "No server certificate presented.";

            var sb = new StringBuilder();
            sb.Append($"Subject={cert.Subject}; Issuer={cert.Issuer}; ");
            sb.Append($"NotBefore={cert.NotBefore:u}; NotAfter={cert.NotAfter:u}; ");
            sb.Append($"Thumbprint={cert.Thumbprint}");

            if (chainIssues is { Length: > 0 })
            {
                var chainText = string.Join("; ",
                    chainIssues.Select(s => $"{s.Status}:{s.StatusInformation?.Trim()}"));
                sb.Append($"; ChainIssues={chainText}");
            }

            return sb.ToString();
        }

        private static string ExplainTlsErrors(SslPolicyErrors e)
        {
            if (e == SslPolicyErrors.None) return string.Empty;

            var parts = new System.Collections.Generic.List<string>();
            if (e.HasFlag(SslPolicyErrors.RemoteCertificateNotAvailable))
                parts.Add("No certificate presented by server.");
            if (e.HasFlag(SslPolicyErrors.RemoteCertificateNameMismatch))
                parts.Add("Hostname mismatch (CN/SAN does not match request host).");
            if (e.HasFlag(SslPolicyErrors.RemoteCertificateChainErrors))
                parts.Add("Chain validation failed (expired/self-signed/missing intermediate).");

            return string.Join(" ", parts);
        }
    }
}
