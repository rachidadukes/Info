using System.Net.Http;
using System.Security.Cryptography.X509Certificates;
using System.Text;

internal static class Program
{
    public static async Task Main(string[] args)
    {
        // Example inputs (replace with yours or read from args/config)
        var endpointUrl = "https://your-service-url/api";
        var thumbprint = "â€ŽAB CD EF 12 34 56 78 90 AB CD EF 12 34 56 78 90 AB CD EF 12"; // can include spaces
        var mimeType = "text/xml"; // or "application/json"
        var content = "<soapenv:Envelope>...</soapenv:Envelope>";

        try
        {
            var response = await PostWithClientCertificateAsync(
                endpointUrl,
                thumbprint,
                content,
                mimeType);

            Console.WriteLine("---- RESPONSE ----");
            Console.WriteLine(response);
        }
        catch (Exception ex)
        {
            Console.WriteLine("ERROR:");
            Console.WriteLine(ex.ToString());
        }
    }

    private static async Task<string> PostWithClientCertificateAsync(
        string endpointUrl,
        string thumbprint,
        string content,
        string mimeType)
    {
        var cert = FindValidCertificateByThumbprint(thumbprint)
                   ?? throw new InvalidOperationException(
                       $"Unable to load certificate with thumbprint: {thumbprint}");

        // IMPORTANT: keep handler alive for the duration of the request.
        using var handler = new HttpClientHandler
        {
            ClientCertificateOptions = ClientCertificateOption.Manual
        };

        handler.ClientCertificates.Add(cert);

        using var httpClient = new HttpClient(handler);

        // If your content is already plain text, do NOT HtmlDecode it.
        // (In your screenshot, HtmlDecode was likely needed because content came HTML-encoded.)
        using var httpContent = new StringContent(content, Encoding.UTF8, mimeType);

        using var response = await httpClient.PostAsync(new Uri(endpointUrl), httpContent);
        var responseBody = await response.Content.ReadAsStringAsync();

        if (!response.IsSuccessStatusCode)
        {
            // include status code for debugging
            throw new HttpRequestException(
                $"HTTP {(int)response.StatusCode} {response.ReasonPhrase}\n{responseBody}");
        }

        return responseBody;
    }

    private static X509Certificate2? FindValidCertificateByThumbprint(string thumbprint)
    {
        var normalized = NormalizeThumbprint(thumbprint);

        // Most services run under identities where LocalMachine is common.
        // Try LocalMachine\My then CurrentUser\My.
        return FindInStore(StoreLocation.LocalMachine, normalized)
            ?? FindInStore(StoreLocation.CurrentUser, normalized);
    }

    private static X509Certificate2? FindInStore(StoreLocation location, string normalizedThumbprint)
    {
        using var store = new X509Store(StoreName.My, location);
        store.Open(OpenFlags.ReadOnly);

        // validOnly: true will filter out expired/not-yet-valid certs.
        var matches = store.Certificates.Find(
            X509FindType.FindByThumbprint,
            normalizedThumbprint,
            validOnly: true);

        // Prefer a cert that has a private key (client cert auth requires it)
        var withPrivateKey = matches
            .OfType<X509Certificate2>()
            .FirstOrDefault(c => c.HasPrivateKey);

        return withPrivateKey ?? matches.OfType<X509Certificate2>().FirstOrDefault();
    }

    private static string NormalizeThumbprint(string thumbprint)
    {
        // Thumbprints often have spaces and sometimes hidden Unicode characters.
        // Keep only hex chars and uppercase them.
        var chars = thumbprint
            .Where(Uri.IsHexDigit)
            .Select(char.ToUpperInvariant)
            .ToArray();

        return new string(chars);
    }
}
