SAMPLE

===========================


using System;
using System.IO;
using System.Net;
using System.ServiceModel;
using System.Xml;
using System.Xml.Serialization;
using NFCU; // <- the namespace that contains FinancialPostingWsClient & data types

namespace CdDepositLegacyConsole
{
    public class CallCurrentService
    {
        // XML-in, XML-out, just like the legacy method
        private async System.Threading.Tasks.Task<string> SendAndReceive(string sSendMessage)
        {
            const string cFunctionName = "SendAndReceive";

            // TLS 1.2 like the VB code
            ServicePointManager.SecurityProtocol = SecurityProtocolType.Tls12;

            // If you store the URL in appsettings.json:
            var settings = HostRoutingConfig.GetHostSettings();
            var endpointUrl = settings["HostURL"]; // e.g. "https://.../FinancialPostingService.svc"

            // 1) Deserialize the request XML -> typed object (CreditAddRq)
            CreditAddRq oRq;
            var reqSerializer = new XmlSerializer(typeof(CreditAddRq));
            using (var txtReader = new StringReader(EnsureNamespaces(sSendMessage)))
            using (var xmlReader = XmlReader.Create(txtReader))
            {
                oRq = (CreditAddRq)reqSerializer.Deserialize(xmlReader);
            }

            // 2) Call the WCF client
            //    The connected service generated FinancialPostingWsClient
            //    You can set the endpoint in code if youâ€™re not using config.
            var binding = new BasicHttpBinding(BasicHttpSecurityMode.Transport); // HTTPS
            binding.MaxReceivedMessageSize = 1024 * 1024; // tune if needed
            var address = new EndpointAddress(endpointUrl);

            string sRecvMessage;
            using (var client = new FinancialPostingWsClient(binding, address))
            {
                // If the proxy exposes depositAsync(CreditAddRq) -> Task<DepositResponseMessage>
                var responseMsg = await client.depositAsync(oRq);

                // 3) Serialize response -> XML string
                //    Pick the serializer that matches the returned type.
                //    Option A: serialize the response message wrapper:
                var respSerializer = new XmlSerializer(typeof(DepositResponseMessage));
                using var sw = new StringWriter();
                respSerializer.Serialize(sw, responseMsg);
                sRecvMessage = sw.ToString();

                // If instead you want the naked payload (e.g., FinancialPostingServiceRs),
                // inspect responseMsg in the debugger and serialize that object instead:
                // var payload = responseMsg?.FinancialPostingServiceRs;
                // var payloadSerializer = new XmlSerializer(typeof(FinancialPostingServiceRs));
                // using var sw2 = new StringWriter();
                // payloadSerializer.Serialize(sw2, payload);
                // sRecvMessage = sw2.ToString();
            }

            return sRecvMessage;
        }

        // Your VB code was string-replacing root elements to add xmlns.
        // Keep that behavior so the XmlSerializer can bind to the generated types.
        private static string EnsureNamespaces(string xml)
        {
            xml = xml.Replace(
                "<MsgRqHdr>",
                "<MsgRqHdr xmlns=\"http://schemas.navyfederal.org/2010/04/NFBranchExService\">");

            xml = xml.Replace(
                "<CreditInfo>",
                "<CreditInfo xmlns=\"http://schemas.navyfederal.org/2010/04/NFBranchExService\">");

            return xml;
        }
    }
}


