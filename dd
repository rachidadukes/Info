SAMPLE
============================

StringReader txtReader = null;
XmlReader xmlReader = null;

try
{
    // Create readers
    txtReader = new StringReader(EnsureNamespaces(sSendMessage));
    xmlReader = XmlReader.Create(txtReader);

    // Deserialize XML into object
    oRq = (CreditAddRq)reqSerializer.Deserialize(xmlReader);
}
finally
{
    // Explicitly dispose of readers to release resources
    if (xmlReader != null)
        xmlReader.Dispose();

    if (txtReader != null)
        txtReader.Dispose();
}

===========================

try
{
    // --- your call ---
    var responseMsg = await client.depositAsync(oRq);

    // serialize response (unchanged)
    var respSerializer = new XmlSerializer(typeof(DepositResponseMessage));
    using var sw = new StringWriter();
    respSerializer.Serialize(sw, responseMsg);
    sRecvMessage = sw.ToString();
}
catch (FaultException fe)                    // SOAP faults from the service
{
    var fault = fe.CreateMessageFault();
    var code   = fe.Code?.ToString();
    var reason = fe.Reason?.ToString();

    // try to pull the <detail/> payload if the service sends one
    string detailText = null;
    if (fault?.HasDetail == true)
    {
        try { detailText = fault.GetDetail<string>(); } catch { /* detail not a string */ }
    }

    Console.WriteLine($"[SOAP FAULT] Code={code} Reason={reason} Detail={detailText}");
    Console.WriteLine(fe.ToString());

    // return a safe, predictable XML error blob
    return $"<Error><Code>{SecurityElement.Escape(code)}</Code><Reason>{SecurityElement.Escape(reason)}</Reason><Detail>{SecurityElement.Escape(detailText)}</Detail></Error>";
}
catch (TimeoutException tex)
{
    Console.WriteLine("[TIMEOUT] " + tex.ToString());
    return $"<Error>Timeout contacting service.</Error>";
}
catch (CommunicationException cex)           // channel / transport problems
{
    Console.WriteLine("[COMM] " + cex.ToString());
    return $"<Error>Communication error contacting service.</Error>";
}
catch (Exception ex)                         // anything else
{
    Console.WriteLine($"[ERROR] SendAndReceive failed: {ex.Message}");
    Console.WriteLine(ex.StackTrace);
    return $"<Error>{SecurityElement.Escape(ex.Message)}</Error>";
}
finally
{
    // Close the client gracefully if it supports it
    try { if (client.State == CommunicationState.Opened) await client.CloseAsync(); } catch { client.Abort(); }
}
