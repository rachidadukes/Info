using System;
using System.Configuration;
using System.Net;
using System.Net.Http;
using System.Security.Authentication;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

public sealed class ApiXmlClientNoCert2
{
    static ApiXmlClientNoCert2()
    {
        // .NET 4.7: lock to TLS 1.2 for legacy endpoints
        ServicePointManager.SecurityProtocol = SecurityProtocolType.Tls12;

        // Optional: some legacy gateways stall on Expect: 100-continue
        ServicePointManager.Expect100Continue = false;

        // DEV ONLY: if you must ignore invalid/self-signed server certs on 4.7.0
        // ServicePointManager.ServerCertificateValidationCallback = (s, cert, chain, errors) => true;
    }

    public async Task<string> PostXmlAsync(string xml, CancellationToken ct = default)
    {
        var endpointUrl = ConfigurationManager.AppSettings["MessageConverterURL"];
        if (string.IsNullOrWhiteSpace(endpointUrl))
            return "CONFIG ERROR: 'MessageConverterURL' missing.";

        try
        {
            // 4.7: use HttpClientHandler; per-call client is OK if you dispose it
            using (var handler = new HttpClientHandler())
            using (var client = new HttpClient(handler))
            {
                client.Timeout = TimeSpan.FromSeconds(30);

                using (var content = new StringContent(xml, Encoding.UTF8, "application/xml"))
                using (var resp = await client.PostAsync(endpointUrl, content, ct).ConfigureAwait(false))
                {
                    return await HandleResponseAsync(resp).ConfigureAwait(false);
                }
            }
        }
        catch (TaskCanceledException ex)
        {
            return "TIMEOUT: The request timed out or was canceled.\n" + Flatten(ex);
        }
        catch (HttpRequestException ex)
        {
            return "HTTP ERROR: network/connection failure.\n" + Flatten(ex);
        }
        catch (AuthenticationException ex)
        {
            return "TLS/SSL HANDSHAKE ERROR.\n" + Flatten(ex);
        }
        catch (Exception ex)
        {
            return "UNHANDLED FAILURE.\n" + Flatten(ex);
        }
    }

    private static async Task<string> HandleResponseAsync(HttpResponseMessage resp)
    {
        var status = (int)resp.StatusCode;
        var reason = resp.ReasonPhrase ?? "";
        var body = await resp.Content.ReadAsStringAsync().ConfigureAwait(false);

        // Helpful single-line trace if you log:
        // System.Diagnostics.Trace.WriteLine($"HTTP {(int)resp.StatusCode} {resp.ReasonPhrase}");

        if (resp.IsSuccessStatusCode)
        {
            // If the service returns logical errors inside a 200 body:
            if (body.IndexOf("<error", StringComparison.OrdinalIgnoreCase) >= 0 ||
                body.IndexOf("error", StringComparison.OrdinalIgnoreCase) >= 0)
            {
                return "LOGICAL ERROR (HTTP 200):\n" + body;
            }

            return body; // happy path: return raw XML/result to caller
        }

        // Map common statuses; include body for diagnostics
        switch (status)
        {
            case 400: return $"400 Bad Request.\n{body}";
            case 401: return $"401 Unauthorized.\n{body}";
            case 403: return $"403 Forbidden.\n{body}";
            case 404: return $"404 Not Found.\n{body}";
            case 415: return $"415 Unsupported Media Type (ensure 'application/xml').\n{body}";
            case 500: return $"500 Internal Server Error.\n{body}";
            default:  return $"{status} {reason}.\n{body}";
        }
    }

    private static string Flatten(Exception ex)
        => ex.Message + (ex.InnerException != null ? "\n" + ex.InnerException.Message : "");
}
