using System.Net.Http;
using System.Net.Security;
using System.Security.Authentication;
using System.Security.Cryptography.X509Certificates;

public static async Task<ProbeResult> TryCallAsync(
    string url,
    X509Certificate2? clientCertificate,
    CancellationToken ct = default)
{
    try
    {
        var handler = new SocketsHttpHandler
        {
            SslOptions = new SslClientAuthenticationOptions
            {
                EnabledSslProtocols = SslProtocols.Tls12 | SslProtocols.Tls13,
                CertificateRevocationCheckMode = X509RevocationMode.Online
            }
        };

        if (clientCertificate != null)
        {
            handler.SslOptions.ClientCertificates =
                new X509CertificateCollection { clientCertificate };
            Console.WriteLine($"[ClientCert] Using {clientCertificate.Subject}");
        }

        // ---- TLS diagnostics (your Console.WriteLines) ----
        handler.SslOptions.RemoteCertificateValidationCallback = (req, cert, chain, errors) =>
        {
            Console.WriteLine($"[TLS] SslPolicyErrors={errors}");

            if (cert != null)
            {
                Console.WriteLine($"[TLS] ServerCert Subject   ={cert.Subject}");
                Console.WriteLine($"[TLS] ServerCert Issuer    ={cert.Issuer}");
                Console.WriteLine($"[TLS] ServerCert NotBefore ={cert.NotBefore:u}");
                Console.WriteLine($"[TLS] ServerCert NotAfter  ={cert.NotAfter:u}");
                Console.WriteLine($"[TLS] ServerCert Thumbprint={cert.GetCertHashString()}");
            }

            if (chain != null)
            {
                for (int i = 0; i < chain.ChainElements.Count; i++)
                {
                    var e = chain.ChainElements[i].Certificate;
                    Console.WriteLine($"[TLS] Chain[{i}] Subject={e.Subject}  Issuer={e.Issuer}  Valid={e.NotBefore:u} - {e.NotAfter:u}");
                }
                if (chain.ChainStatus.Length > 0)
                {
                    Console.WriteLine("[TLS] Chain Status:");
                    foreach (var s in chain.ChainStatus)
                        Console.WriteLine($"    {s.Status}: {s.StatusInformation?.Trim()}");
                }
            }

            // stay strict
            return errors == SslPolicyErrors.None;
        };
        // ---------------------------------------------------

        using var client = new HttpClient(handler) { Timeout = TimeSpan.FromSeconds(20) };

        using var req = new HttpRequestMessage(HttpMethod.Get, url)
        {
            Version = new Version(2, 0),
            VersionPolicy = HttpVersionPolicy.RequestVersionOrHigher
        };

        var resp = await client.SendAsync(req, ct);                   // <-- await fixes CS1998
        var body = await resp.Content.ReadAsStringAsync(ct);          // <-- await fixes CS1998

        if (body.Length > 300) body = body[..300] + "...";

        var status = resp.IsSuccessStatusCode ? ProbeStatus.Success : ProbeStatus.HttpError;
        return new ProbeResult(status, $"HTTP {(int)resp.StatusCode} {resp.ReasonPhrase}\n{body}");
    }
    catch (AuthenticationException ae)
    {
        Console.ForegroundColor = ConsoleColor.Red;
        Console.WriteLine("❌ AuthenticationException:");
        Console.WriteLine(ae);
        Console.ResetColor();
        return new ProbeResult(ProbeStatus.HandshakeFailed, ae.ToString()); // <-- guarantees return fixes CS0161
    }
    catch (HttpRequestException hre)
    {
        Console.ForegroundColor = ConsoleColor.Yellow;
        Console.WriteLine("⚠️ HttpRequestException:");
        Console.WriteLine(hre);
        Console.ResetColor();
        return new ProbeResult(ProbeStatus.NetworkError, hre.ToString());
    }
    catch (TaskCanceledException tce)
    {
        return new ProbeResult(ProbeStatus.NetworkError, $"Timeout/Cancelled: {tce.Message}");
    }
    catch (Exception ex)
    {
        return new ProbeResult(ProbeStatus.UnknownError, ex.ToString());
    }
}
