using System.Net.Http;
using System.Net.Security;
using System.Security.Authentication;
using System.Security.Cryptography.X509Certificates;

// Build handler with per-request TLS settings
var handler = new SocketsHttpHandler
{
    // Configure allowed TLS versions
    SslOptions = new SslClientAuthenticationOptions
    {
        EnabledSslProtocols = SslProtocols.Tls12 | SslProtocols.Tls13,
        CertificateRevocationCheckMode = X509RevocationMode.Online
    }
};

// Attach client certificate if available
if (clientCertificate != null)
{
    handler.SslOptions.ClientCertificates = new X509CertificateCollection { clientCertificate };
    Console.WriteLine($"[ClientCert] Using {clientCertificate.Subject}");
}

// üîç Detailed TLS validation logging
handler.SslOptions.RemoteCertificateValidationCallback = (req, cert, chain, errors) =>
{
    Console.WriteLine($"[TLS] SslPolicyErrors = {errors}");

    if (cert != null)
    {
        Console.WriteLine($"[TLS] ServerCert Subject     = {cert.Subject}");
        Console.WriteLine($"[TLS] ServerCert Issuer      = {cert.Issuer}");
        Console.WriteLine($"[TLS] ServerCert NotBefore   = {cert.NotBefore:u}");
        Console.WriteLine($"[TLS] ServerCert NotAfter    = {cert.NotAfter:u}");
        Console.WriteLine($"[TLS] ServerCert Thumbprint  = {cert.GetCertHashString()}");
    }

    if (chain != null)
    {
        for (int i = 0; i < chain.ChainElements.Count; i++)
        {
            var e = chain.ChainElements[i].Certificate;
            Console.WriteLine($"[TLS] Chain[{i}] Subject={e.Subject}");
            Console.WriteLine($"[TLS] Chain[{i}] Issuer={e.Issuer}");
            Console.WriteLine($"[TLS] Chain[{i}] Valid={e.NotBefore:u} - {e.NotAfter:u}");
        }

        if (chain.ChainStatus.Length > 0)
        {
            Console.WriteLine("[TLS] Chain Status:");
            foreach (var s in chain.ChainStatus)
                Console.WriteLine($"    {s.Status}: {s.StatusInformation?.Trim()}");
        }
    }

    // Keep strict validation ‚Äî only return true if no policy errors
    return errors == SslPolicyErrors.None;
};

// Create HttpClient
using var client = new HttpClient(handler)
{
    Timeout = TimeSpan.FromSeconds(15)
};

// Example call (GET or POST)
try
{
    var resp = await client.GetAsync(url);
    var status = resp.IsSuccessStatusCode ? ProbeStatus.Success : ProbeStatus.HttpError;
    var body = await resp.Content.ReadAsStringAsync();
    if (body.Length > 300) body = body[..300] + "...";
    return new ProbeResult(status, $"HTTP {(int)resp.StatusCode} {resp.ReasonPhrase}\n{body}");
}
catch (AuthenticationException ae)
{
    Console.ForegroundColor = ConsoleColor.Red;
    Console.WriteLine("‚ùå AuthenticationException:");
    Console.WriteLine(ae);
    Console.ResetColor();
    return new ProbeResult(ProbeStatus.HandshakeFailed, ae.Message);
}
catch (HttpRequestException hre)
{
    Console.ForegroundColor = ConsoleColor.Yellow;
    Console.WriteLine("‚ö†Ô∏è HttpRequestException:");
    Console.WriteLine(hre);
    Console.ResetColor();
    return new ProbeResult(ProbeStatus.NetworkError, hre.Message);
}
