using Microsoft.EntityFrameworkCore;               // for ExecuteSqlRawAsync, IsSqlite()

public async Task<string> SaveLogsToSQLiteDb(
    DbContextSQLite dbContext,
    IEnumerable<NewLogDto> newLogsFound,
    CancellationToken ct = default)
{
    if (newLogsFound is null)
        return "No logs to save.";

    // 1) Map in memory (no awaits, no EF calls)
    var entities = newLogsFound.Select(n => new OriginalLogsModel
    {
        Environment   = n.Environment,
        EventDesc     = n.EventDesc,
        EventID       = n.EventID,
        UserID        = n.UserID,
        DateTimeStamp = n.DateTimeStamp
    }).ToArray();

    if (entities.Length == 0)
        return "No logs to save.";

    // Optional: dedupe by natural key before insert
    // entities = entities.DistinctBy(e => new { e.Environment, e.EventID, e.DateTimeStamp }).ToArray();

    // 2) Single EF operation
    var originalDetect = dbContext.ChangeTracker.AutoDetectChangesEnabled;
    dbContext.ChangeTracker.AutoDetectChangesEnabled = false;

    await using var tx = await dbContext.Database.BeginTransactionAsync(ct);
    try
    {
        // Only apply PRAGMAs when using SQLite
        if (dbContext.Database.IsSqlite())
        {
            await dbContext.Database.ExecuteSqlRawAsync("PRAGMA journal_mode=WAL;", ct);
            await dbContext.Database.ExecuteSqlRawAsync("PRAGMA synchronous=NORMAL;", ct);
        }

        await dbContext.OriginalLogs.AddRangeAsync(entities, ct);
        var inserted = await dbContext.SaveChangesAsync(ct);

        await tx.CommitAsync(ct);
        return $"{inserted} logs saved to SQLite successfully.";
    }
    catch (Exception ex)
    {
        await tx.RollbackAsync(ct);
        return $"Error inserting logs: {ex.Message}";
    }
    finally
    {
        dbContext.ChangeTracker.AutoDetectChangesEnabled = originalDetect;
    }
}
