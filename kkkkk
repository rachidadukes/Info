
private static async Task<bool> TryTcpConnectAsync(Uri uri, ApiHealthDiag diag, CancellationToken ct)
{
    try
    {
        using var tcp = new TcpClient();
        var port = uri.Port == -1 ? 443 : uri.Port;

        var ok = await ConnectWithTimeoutAsync(tcp, uri.Host, port, TimeSpan.FromSeconds(TcpConnectSeconds), ct);
        diag.TcpOk = ok && tcp.Connected;

        if (!diag.TcpOk)
        {
            diag.PhaseFailed = "TCP";
            diag.Reason = "Connect timeout/refused.";
            return false;
        }

        return true;
    }
    catch (Exception ex)
    {
        diag.PhaseFailed = "TCP";
        diag.Reason = ex.Message;
        return false;
    }
}

// Portable helper: works on .NET Framework/Core/5+/6+/8+/9+
private static async Task<bool> ConnectWithTimeoutAsync(
    TcpClient tcp, string host, int port, TimeSpan timeout, CancellationToken ct)
{
    using var cts = CancellationTokenSource.CreateLinkedTokenSource(ct);
    var connectTask = tcp.ConnectAsync(host, port);

#if NET6_0_OR_GREATER
    // .NET 6+ has WaitAsync(TimeSpan) â€” no CT overload in 6/7; .NET 8 adds it but this keeps it portable.
    var completed = await connectTask.WaitAsync(timeout);
    if (completed) { await connectTask; return true; }
    return false;
#else
    // Framework / older runtimes: emulate WaitAsync with WhenAny
    var delayTask = Task.Delay(timeout, cts.Token);
    var winner = await Task.WhenAny(connectTask, delayTask);
    if (winner == connectTask)
    {
        cts.Cancel();            // stop the delay if connect won
        await connectTask;       // observe exceptions if any
        return true;
    }
    return false;                // timeout
#endif
}
